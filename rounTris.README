## README for RounTris 


Controller -
handles keyboard input and calls functions on world accordingly


Control.state = // one of these: preGame, playing, paused, gameWon, gameLost

Control.pause(){
	//pauses
}


Control.keyDown(){
	sends key to ActionBuffer to parse and send on to Model
	//Puts key in buffer (cancels contradictory inputs)
	
}

Control.tick(){
	//ticks the world and 
	//queries the state
	//then calls View.tick(worldState)
}


Class ActionBuffer /transaltes keys into actions and passes them to the world object
  function name + arg array


View - 

View.startScreen(){
	//draws the start screen
}

View.endScreen(){
	//Shows the end screen, like game over + high score + play again button
}

View.drawWorld(){
	
}

View.drawHud(){
	//draw's score, level, paused state?
	
}

View.tick(worldState){
	this.drawWorld(worldState)
}

View.onKeyDown(event){
	Control.keyDown(event.key);
}






Block -
describes the blocks in the game world, mainly shape differences - maybe subclassed

each block subclass may rotate differently.




World - 
''
const gameWorld = new World(width, height, lossHeight)
//Should return gameworld object
//with a grid according to arguments

World.genRate //Rate at which blocks are generated in seconds
World.dropRate //Rate at which blocks drop in space in seconds


const blocks = [];
const debris = [];

World.init(){ //is this really necessary?
	//Builds a data model of the world
	//ie
	000000000
	000000000
	000000000
	000x00000
	000x00000 //abandon this model?
	xxxxxxxxx
}

World.tick(playerInput, delta){
	//updates the world based on user input
	//if enough time has passed drops the blocks

}

World._dropBlocks(){
	//drops all falling blocks by 1 if they can,
	//otherwise moves them to debris array

	//checks to see if this triggers loss
	//if loss then change the state
}

World._spawnBlock(blockType){
	//should spawn blocks of blockType
}

World._destroy(row){
	//removes all blocks from this row
}

World._wrapX(xIn){
	//Should take an x and wrap it around the world
	//in case it's out of bounds
}

World.spinStuck(rightOrLeft){
	//Shifts all stuck blocks left or right
}


World.spingFalling(){
	//rotates all blocks in midair according to their block rotation
}






//Need some sort of callback set up as files are loaded aSyncronysly 
function SoundControl(){

	const soundSources = {
		'keyName' : 'filePath',
		'keyName' : 'filePath',
	}

	function logLoad(){
		soundsLoaded += 1;
		if (soundsLoaded==Object.keys(soundSources).length)
			finishedLoadingSound();
	}

	const loadSound = function(filePath, bufferKey){
		var request = new XMLHttpRequest();
		request.open('GET', url, true);
		request.responseType = 'arraybuffer';

		// Decode asynchronously
		request.onload = function() {
		    context.decodeAudioData(request.response, function(buffer) {
			    soundBuffers[bufferKey] = buffer;
      logLoad();
    });
  }
  request.send();

	}



	return {
		fillBuffers : function () {
			//Loads each sound file;
		}

		playEffect : function (effectKey) {
			//Plays sound effect from library
		}

		playMusic : function (musicKey){
			//Plays music from looping buffer;
		}

		stopMusic : function () {
			//Stops music playback
		}

	}	
}


//Separate Sound Manager
has one sound buffer for effects
and another looping buffer for music/ambient